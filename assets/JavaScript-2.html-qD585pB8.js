import{_ as n,o as s,c as a,b as e}from"./app-zVI8MIRp.js";const o={},t=e(`<h2 id="经典真题" tabindex="-1"><a class="header-anchor" href="#经典真题" aria-hidden="true">#</a> 经典真题</h2><ul><li><em>JS</em> 中的数据类型有哪些？基本类型和引用类型的区别是什么？</li></ul><h2 id="_1-简单值和复杂值" tabindex="-1"><a class="header-anchor" href="#_1-简单值和复杂值" aria-hidden="true">#</a> 1. 简单值和复杂值</h2><p><em>JS</em> 的数据类型就分为两大类：</p><ul><li>简单值（基本类型、原始类型）</li><li>复杂值（引用类型、引用值）</li></ul><h3 id="_1-1-简单值" tabindex="-1"><a class="header-anchor" href="#_1-1-简单值" aria-hidden="true">#</a> 1.1. 简单值</h3><p>一共有 <em>7</em> 种：</p><ul><li><em>number</em> 数字</li><li><em>string</em> 字符串</li><li><em>boolean</em> 布尔值</li><li><em>null</em> 空值</li><li><em>undefined</em> 未定义</li><li><em>symbol</em> 符号</li><li><em>bigint</em> 大数</li></ul><p>所谓简单值，是因为<strong>这些类型的值，无法再继续往下拆分</strong>。</p><h4 id="_1-1-1-注意" tabindex="-1"><a class="header-anchor" href="#_1-1-1-注意" aria-hidden="true">#</a> 1.1.1. 注意</h4><ol><li><p><strong><em>symbol</em></strong> 和 <strong><em>bigint</em></strong></p><ul><li>这两个数据类型是从 <em>ES6</em> 开始新增的。</li><li><em>symbol</em> 主要用于<strong>创建唯一的标识符</strong>。<em>symbol</em> 的值是唯一且不可变的，适用于作为对象属性的键，以及保证不会与其他属性键发生冲突，特别是在多人合作的大型项目中或着是用第三方库的时候。</li><li><em>bigint</em> 是一个新增的基础数据类型，它于 <em>ECMAScript 2020</em>（<em>ES11</em>）中被正式添加到语言标准中。<em>bigint</em> 数据类型用于表示大于 <code>Number.MAX_SAFE_INTERGER</code>（即 <code>2^53 - 1</code>）或小于 <code>Number.MIN_SAFE_INTERGER</code>（即 <code>-2^53 + 1</code>）的整数。这个类型<strong>提供了一种在 <em>JS</em> 中安全处理非常大的整数的方法</strong>，这在之前的 <em>JS</em> 版本中是不可能的。这种类型非常适合用于在金融、科学计算和加密等领域。</li></ul></li><li><p><strong><em>null</em></strong> 和 <strong><em>undefined</em></strong></p></li></ol><blockquote><p>问题 1：为什么 <em>null</em> 的数据类型打印出来是 <em>object</em> ?</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这是 <em>JS</em> 从第一个版本开始时，<strong>设计上的一个遗留问题</strong>。最初的 <em>JS</em> 语言实现是在 <em>1995</em> 年由 <em>Brendan Eich</em> 在 <em>Netscape Navigator</em> 中设计的。在 <em>JS</em> 最初的版本中，<strong>数据类型是使用底层的位模式来标识的，每种数据类型的前几位是用来表示类型信息的</strong>。例如，<strong>对象的类型标记通常以 <em>00</em> 开头</strong>，而由于一个历史错误，<strong><em>null</em> 被表示为全零（<em>00000000</em>）</strong>，这就使得 <em>null</em> 的类型检查结果与对象一致。</p><p>虽然这个行为在技术上是不正确的（因为 <em>null</em> 既不是对象也不包含任何属性），但改变这个行为可能会破坏大量现存的 <em>Web</em> 页面和应用。因此，尽管这是一个众所周知的问题，但由于向后兼容性的考虑，这个设计决策一直未被修改。</p><p>不仅没有被修改，这个行为目前还被 <em>ECMAScript</em> 标准所采纳，成为了规范的一部分，所有遵循 <em>ECMAScript</em> 标准的 <em>JS</em> 实现都默认在 <em>typeof null</em> 时返回 <em>object</em>。</p><blockquote><p>问题 2：为什么 <em>undefined</em> 和 <em>null</em> 明明是两种基础数据类型，但 <code>undefined == null</code> 返回的是 <code>true</code> ?</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">undefined</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这是由语言规范决定的。</p><ul><li><p><code>undefined</code> 表示变量未定义或未赋值，而 <code>null</code> 表示变量已定义但值为空。尽管含义不同，但它们都表示 “无值” 状态，因此在某些情况下可以互换。</p></li><li><p>在非严格相等比较（==）中，<em>JavaScript</em> 会进行隐式类型转换。根据规范，<code>undefined</code> 和 <code>null</code> 在比较时都不会转换为其他类型，且它们都被认为是 “假值”，因此 <code>undefined == null</code> 返回 <code>true</code>。</p></li><li><p>根据 <em>ECMAScript</em> 规范，<code>undefined == null</code> 是明确规定的行为。</p></li></ul><p>注意：</p><ul><li>使用严格相等（===）时，<code>undefined</code> 和 <code>null</code> 不相等，因为它们的类型不同（<code>undefined</code> 是 <code>undefined</code> 类型，<code>null</code> 是 <code>object</code> 类型）。</li></ul><p>目前，关于 <code>null</code> 和 <code>undefined</code> 的一些区别：</p><ul><li><code>null</code>：表示一个明确的 &quot;空值&quot; 或 &quot;无对象&quot; 的占位符。 <ul><li>显式地将一个变量设置为 &quot;空值&quot;。</li><li>作为函数地返回值，表示 &quot;无结果&quot; 或 &quot;无对象&quot;。</li><li>作为对象属性的值，表示该属性为 &quot;空&quot;。如原型链的终点。</li><li>转为数值时会被转换为 <code>0</code>。</li></ul></li><li><code>undefined</code>：表示变量已声明但未赋值，或者访问对象中不存在的属性。 <ul><li>变量声明但未初始化时，默认值为 <code>undefined</code>。</li><li>函数没有明确返回值时，默认返回 <code>undefined</code>。</li><li>访问对象中不存在的属性时，返回 <code>undefined</code>。</li><li>转为数值时值为 <code>NaN</code>。</li></ul></li></ul><h3 id="_1-2-复杂值" tabindex="-1"><a class="header-anchor" href="#_1-2-复杂值" aria-hidden="true">#</a> 1.2. 复杂值</h3><p>就一种：</p><ul><li><em>object</em></li></ul><p>之所以称为复杂值，就是因为<strong>这种类型的值可以继续往下拆分</strong>，分为多个简单值或复杂值。</p><p><strong>数组、函数、正则这些统统都是对象类型，属于复杂值</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token operator">/</span>ab<span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>函数的本质也是对象</strong>。可以添加属性和方法。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

fun<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&#39;aaaa&#39;</span><span class="token punctuation">;</span>
fun<span class="token punctuation">.</span><span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;this is a test function&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// aaaa</span>
fun<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this is a test function</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在函数内部，有一个特别的内部属性 <code>[[Call]]</code>，这属于内部代码，开发者层面是没有办法调用的。<strong>有了这个属性之后，表示这个对象是可以被调用</strong>。</p><p>因为函数是可调用的对象，为了区分<strong>普通对象</strong>和<strong>函数对象</strong>，当我们用 <code>typeof</code> 操作符检测一个函数时，返回的是 <code>function</code>。</p><p>正因为这种设计，所以 <em>JS</em> 中能够实现高阶函数。高阶函数定义如下（满足一个条件即可）：</p><ul><li>接受一个或多个函数作为输入。</li><li>输出一个函数。</li></ul><p>因为在 <em>JS</em> 中，函数的本质就是对象，所以可以像普通对象一样，作为参数或返回值进行传递。</p>`,37),c=[t];function p(l,i){return s(),a("div",null,c)}const d=n(o,[["render",p],["__file","JavaScript-2.html.vue"]]);export{d as default};
