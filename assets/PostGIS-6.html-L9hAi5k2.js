import{_ as a,r as o,o as r,c as i,d as s,e as n,f as t,b as p}from"./app-zVI8MIRp.js";const l="/vuepress-blog/assets/image1-zDlLzUqP.png",c="/vuepress-blog/assets/image2-ydT3n19H.png",d="/vuepress-blog/assets/image3-yt81Em43.png",u="/vuepress-blog/assets/image4-BLJIDjDJ.png",g="/vuepress-blog/assets/image5-mDpCZyEo.png",_="/vuepress-blog/assets/image6-r2Eq-MLq.png",m="/vuepress-blog/assets/image7--A662SNN.png",h="/vuepress-blog/assets/image8-jnvBxinB.png",v="/vuepress-blog/assets/image9-oHwQw5NY.png",k="/vuepress-blog/assets/image10-D98qS5rB.png",T="/vuepress-blog/assets/image11-4l-1h5C0.png",b="/vuepress-blog/assets/image12-0E2Vqs_8.png",S="/vuepress-blog/assets/image13-RiHbd1pR.png",E="/vuepress-blog/assets/image14-Y6Ev_Sb2.png",x={},y=p('<p>到目前为止，我们仅使用了测量（<strong>ST_Area</strong>、<strong>ST_Length</strong>）、序列化（<strong>ST_GeomFromText</strong>）或反序列化（<strong>ST_AsGML</strong>）几何图形的空间函数。这些函数的共同点是它们每次只能处理一个几何图形。</p><p>空间数据库的功能强大，因为它们不仅存储几何图形，还能够比较<em>几何图形之间的关系</em>。</p><p>诸如“哪个自行车架离公园最近？”或“地铁线路和街道的交叉口在哪里？”之类的问题只能通过比较代表自行车架、街道和地铁线路的几何图形来回答。</p><p>OGC 标准定义了以下一组方法来比较几何。</p><h2 id="_6-1-st-equals" tabindex="-1"><a class="header-anchor" href="#_6-1-st-equals" aria-hidden="true">#</a> 6.1. ST_Equals</h2><p><code>ST_Equals(几何 A, 几何 B)</code>测试两个几何的空间相等性。</p><p><img src="'+l+`" alt="alt text"></p><p>如果两个相同类型的几何图形具有相同的 x,y 坐标值，即第二个形状与第一个形状相等（相同），则 ST_Equals 返回 TRUE。</p><blockquote><p>示例</p></blockquote><ol><li><p>首先，让我们从<code>nyc_subway_stations</code>表中检索一个点的表示。我们只取“Broad St”的条目。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> geom
<span class="token keyword">FROM</span> nyc_subway_stations
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Broad St&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+c+`" alt="alt text"></p></li><li><p>然后，将几何表示重新插入到<strong>ST_Equals</strong>测试中：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name
<span class="token keyword">FROM</span> nyc_subway_stations
<span class="token keyword">WHERE</span> ST_Equals<span class="token punctuation">(</span>geom<span class="token punctuation">,</span> <span class="token string">&#39;0101000020266900000EEBD4CF27CF2141BC17D69516315141&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+d+`" alt="alt text"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注释:
点的表示不太人性化（0101000020266900000EEBD4CF27CF2141BC17D69516315141），但它是坐标值的精确表示。对于相等性之类的测试，使用精确坐标是必要的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="_6-2-st-intersects、st-disjoint、st-crosses-和-st-overlaps" tabindex="-1"><a class="header-anchor" href="#_6-2-st-intersects、st-disjoint、st-crosses-和-st-overlaps" aria-hidden="true">#</a> 6.2. ST_Intersects、ST_Disjoint、ST_Crosses 和 ST_Overlaps</h2><p><strong>ST_Intersects</strong>、<strong>ST_Crosses</strong>和<strong>ST_Overlaps</strong>测试几何内部是否相交。</p><h3 id="_6-2-1-intersects" tabindex="-1"><a class="header-anchor" href="#_6-2-1-intersects" aria-hidden="true">#</a> 6.2.1. Intersects</h3><p><img src="`+u+'" alt="alt text"></p><p>如果两个形状具有任何共同空间（即它们的边界或内部相交），则<strong>ST_Intersects(geometry A, geometry B)返回 t（TRUE）。</strong></p><h3 id="_6-2-2-disjoint" tabindex="-1"><a class="header-anchor" href="#_6-2-2-disjoint" aria-hidden="true">#</a> 6.2.2. <strong>Disjoint</strong></h3><p><img src="'+g+'" alt="alt text"></p><p><strong>ST_Intersects</strong> 的反义词是<strong>ST_Disjoint(geometry A, geometry B)</strong>。如果两个几何图形不相交，则它们不相交，反之亦然。事实上，测试“相交”通常比测试“不相交”更有效，因为相交测试可以进行空间索引，而不相交测试则不能。</p><h3 id="_6-2-3-cross" tabindex="-1"><a class="header-anchor" href="#_6-2-3-cross" aria-hidden="true">#</a> 6.2.3. Cross</h3><p><img src="'+_+'" alt="alt text"></p><p>对于多点/多边形、多点/线串、线串/线串、线串/多边形和线串/多多边形比较，如果交集产生的几何图形的维度比两个源几何图形的最大维度小一，并且交集位于两个源几何图形的内部，则<strong>ST_Crosses(几何图形 A, 几何图形 B)返回 t (TRUE)。</strong></p><h3 id="_6-2-4-overlap" tabindex="-1"><a class="header-anchor" href="#_6-2-4-overlap" aria-hidden="true">#</a> 6.2.4. Overlap</h3><p><img src="'+m+`" alt="alt text"></p><p><code>ST_Overlaps(几何图形 A, 几何图形 B)</code>比较两个相同维度的几何图形，如果它们的交集结果为不同于两者但具有相同维度的几何图形，则返回 TRUE。</p><blockquote><p>示例</p></blockquote><p>以 Broad Street 地铁站为例，并使用<strong>ST_Intersects</strong>函数确定其邻近区域：</p><ol><li><p>查询<code>Broad St</code>的地铁站几何信息(wkt格式)</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> ST_AsText<span class="token punctuation">(</span>geom<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> nyc_subway_stations
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Broad St&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+h+`" alt="alt text"></p></li><li><p>确定临近区域</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> boroname
<span class="token keyword">FROM</span> nyc_neighborhoods
<span class="token keyword">WHERE</span> ST_Intersects<span class="token punctuation">(</span>geom<span class="token punctuation">,</span> ST_GeomFromText<span class="token punctuation">(</span><span class="token string">&#39;POINT(583571.9059213118 4506714.341192182)&#39;</span><span class="token punctuation">,</span><span class="token number">26918</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+v+'" alt="alt text"></p></li></ol><h2 id="_6-3-st-touches" tabindex="-1"><a class="header-anchor" href="#_6-3-st-touches" aria-hidden="true">#</a> 6.3. ST_Touches</h2><p><strong>ST_Touches</strong>测试两个几何图形是否在其边界处接触，但在其内部不相交</p><p><img src="'+k+'" alt="alt text"></p><p>如果任一几何图形的边界相交，或者只有一个几何图形的内部与另一个几何图形的边界相交，则<strong>ST_Touches(geometry A, geometry B)返回 TRUE。</strong></p><h2 id="_6-4-st-within-和-st-contains" tabindex="-1"><a class="header-anchor" href="#_6-4-st-within-和-st-contains" aria-hidden="true">#</a> 6.4. ST_Within 和 ST_Contains</h2><p><strong>ST_Within</strong>和<strong>ST_Contains</strong>测试一个几何图形是否完全位于另一个几何图形内。</p><p><img src="'+T+`" alt="alt text"></p><p>如果第一个几何图形完全位于第二个几何图形内，则<strong>ST_Within(geometry A, geometry B)返回 TRUE</strong>。ST_Within 测试的结果与 ST_Contains 完全相反。</p><p>如果第二个几何图形完全包含在第一个几何图形中，则<strong>ST_Contains(geometry A, geometry B)返回 TRUE。</strong></p><h2 id="_6-5-st-distance-和-st-dwithin" tabindex="-1"><a class="header-anchor" href="#_6-5-st-distance-和-st-dwithin" aria-hidden="true">#</a> 6.5. ST_Distance 和 ST_DWithin</h2><p>一个极为常见的 GIS 问题是“找到距离该物体 X 范围内的所有物体”。</p><p><code>ST_Distance (几何图形 A, 几何图形 B)</code>计算两个几何图形之间的<em>最短</em>距离并将其作为浮点数返回。这对于实际报告对象之间的距离非常有用。</p><blockquote><p>示例-计算两个几何体间的最短距离</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> ST_Distance<span class="token punctuation">(</span>
  ST_GeometryFromText<span class="token punctuation">(</span><span class="token string">&#39;POINT(0 5)&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  ST_GeometryFromText<span class="token punctuation">(</span><span class="token string">&#39;LINESTRING(-2 2, 2 2)&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+b+'" alt="alt text"></p><p>为了测试两个对象是否在彼此的距离之内，<strong>ST_DWithin</strong>函数提供了索引加速的真/假测试。这对于诸如“道路 500 米缓冲区内有多少棵树？”之类的问题非常有用。您不必计算实际的缓冲区，只需测试距离关系即可。</p><p><img src="'+S+`" alt="alt text"></p><blockquote><p>示例</p><p>再次使用我们的 Broad Street 地铁站，我们可以找到地铁站附近的街道（10 米以内）：</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name
<span class="token keyword">FROM</span> nyc_streets
<span class="token keyword">WHERE</span> ST_DWithin<span class="token punctuation">(</span>
        geom<span class="token punctuation">,</span>
        ST_GeomFromText<span class="token punctuation">(</span><span class="token string">&#39;POINT(583571 4506714)&#39;</span><span class="token punctuation">,</span><span class="token number">26918</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token number">10</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+E+'" alt="alt text"></p><h2 id="_6-6-函数列表" tabindex="-1"><a class="header-anchor" href="#_6-6-函数列表" aria-hidden="true">#</a> 6.6. 函数列表</h2>',48),q={href:"http://postgis.net/docs/ST_Contains.html",target:"_blank",rel:"noopener noreferrer"},B={href:"http://postgis.net/docs/ST_Crosses.html",target:"_blank",rel:"noopener noreferrer"},f={href:"http://postgis.net/docs/ST_Disjoint.html",target:"_blank",rel:"noopener noreferrer"},C={href:"http://postgis.net/docs/ST_Distance.html",target:"_blank",rel:"noopener noreferrer"},w={href:"http://postgis.net/docs/ST_DWithin.html",target:"_blank",rel:"noopener noreferrer"},A={href:"http://postgis.net/docs/ST_Equals.html",target:"_blank",rel:"noopener noreferrer"},R={href:"http://postgis.net/docs/ST_Intersects.html",target:"_blank",rel:"noopener noreferrer"},D={href:"http://postgis.net/docs/ST_Overlaps.html",target:"_blank",rel:"noopener noreferrer"},I={href:"http://postgis.net/docs/ST_Touches.html",target:"_blank",rel:"noopener noreferrer"},W={href:"http://postgis.net/docs/ST_Within.html",target:"_blank",rel:"noopener noreferrer"};function F(L,O){const e=o("ExternalLinkIcon");return r(),i("div",null,[y,s("p",null,[s("a",q,[n("ST_Contains(geometry A, Geometry B)"),t(e)]),n(" :当且仅当B的任何点都不位于A的外部，并且B的内部至少有一个点位于A的内部时，返回true。")]),s("p",null,[s("a",B,[n("ST_Crosses(几何 A, 几何 B)"),t(e)]),n("：如果所提供的几何图形有一些（但不是全部）共同的内部点，则返回 TRUE。")]),s("p",null,[s("a",f,[n("ST_Disjoint(几何图形 A, 几何图形 B)"),t(e)]),n("：如果几何图形不“空间相交” - 如果它们不共享任何空间，则返回 TRUE。")]),s("p",null,[s("a",C,[n("ST_Distance（几何 A，几何 B）"),t(e)]),n("：以投影单位返回两个几何体之间的二维笛卡尔最小距离（基于空间参考）。")]),s("p",null,[s("a",w,[n("ST_DWithin(几何图形 A, 几何图形 B, 半径)"),t(e)]),n("：如果几何图形彼此在指定的距离（半径）内，则返回 true。")]),s("p",null,[s("a",A,[n("ST_Equals(geometry A, geometry B)"),t(e)]),n("：如果给定的几何图形表示相同的几何图形，则返回 true。方向性被忽略。")]),s("p",null,[s("a",R,[n("ST_Intersects(geometry A, Geometry B)"),t(e)]),n(" : 如果几何/地理“空间相交”（任意部分重叠），则返回 TRUE，否则返回（FALSE 它们不相交）。")]),s("p",null,[s("a",D,[n("ST_Overlaps（几何图形 A，几何图形 B）"),t(e)]),n("：如果几何图形共享空间、具有相同的维度，但彼此并不完全包含，则返回 TRUE。")]),s("p",null,[s("a",I,[n("ST_Touches(几何图形 A, 几何图形 B)"),t(e)]),n("：如果几何图形至少有一个共同点，但它们的内部不相交，则返回 TRUE。")]),s("p",null,[s("a",W,[n("ST_Within(几何图形 A，几何图形 B)"),t(e)]),n("：如果几何图形 A 完全位于几何图形 B 内部，则返回 true")])])}const U=a(x,[["render",F],["__file","PostGIS-6.html.vue"]]);export{U as default};
